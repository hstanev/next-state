/**
 * Configurable mOdule that remembers the nextState on each transition. When a transition is intercepted(we are redirected to a state that is configured as not to be remembered) for some reason this module ensures to redirect the user to the previous intended state
 * @version v1.0.0 - 2017-01-13 * @link https://github.com/hstanev/next-state#readme
 * @author Radina Staneva
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */"use strict";var app=angular.module("resolve.next-state",["ui.router","permission","permission.ui"]);app.provider("nextState",function(){this.excludedStates=[],this.redirectEvents=[],this.defaultHomeRedirect="",this.memos={},this.setExcludedStates=function(a){this.excludedStates=a},this.setRedirectEvents=function(a){this.redirectEvents=a},this.setDefaultHomeRedirect=function(a){this.defaultHomeRedirect=a},this.excludedStates=function(){return excludedStates},this.redirectEvents=function(){return redirectEvents},this.defaultHomeRedirect=function(){return defaultHomeRedirect},this.memo=function(a,b){this.memos[a]=b},this.forget=function(a){delete this.memos[a]},this.get=function(a){return this.memos[a]},this.clear=function(){this.memos.length=0};var a=this;this.$get=function(){return{excludedStates:function(){return a.excludedStates},redirectEvents:function(){return a.redirectEvents},defaultHomeRedirect:function(){return a.defaultHomeRedirect},memo:function(b,c){return a.memo(b,c)},forget:function(b){return a.forget(b)},get:function(b){return a.get(b)},clear:function(){return a.clear}}}}),app.run(["$rootScope","$state","nextState",function(a,b,c){a.$on("$stateChangeStart",function(a,b,d,e,f){_.contains(c.excludedStates(),b.name)||c.memo("redirect",b)}),a.$on("$stateChangePermissionStart",function(a,b,d,e){_.contains(c.excludedStates(),b.name)||c.memo("redirect",b)}),angular.forEach(c.redirectEvents(),function(d){a.$on(d,function(a,d){var e=c.get("redirect");angular.isUndefined(e)?b.go(c.defaultHomeRedirect()):(b.go(e),c.clear())})})}]);